// 1. База начальных убеждений

sellers([seller1, seller2, seller3]). //список продавцов.
!toPutOnQueue. // начальная цель – встать в очередь.

// 2. Планы по достижению целей (табл. 6)
@c1 +!toPutOnQueue <-
	.wait(200);
	.print("Hello! Who is last?");
	.broadcast(achieve, who_is_last).
/*Данный план, в соответствии с изначально заданной целью, срабатывает первым, сразу после
создания клиента. В плане выводится приветственное сообщение и всем агентам МАС
(в строке №10) рассылается запрос «кто крайний?». Конечно, с рациональной точки зрения
совсем не нужно рассылать этот запрос всем агентам, поскольку он важен только для клиентов
в очередях. Но, с одной стороны, в жизни, когда вы в фастфуде громко спрашиваете «кто
крайний?», Вас вполне может услышать повар. Просто он не реагируют на Ваш запрос, поскольку
это не в его обязанностях. А с другой стороны, без модели физической среды нет иного
способа получить эту информацию, поскольку только что созданный агент-клиент вообще не
имеет никакого представления о наличии и расположении других клиентов
В строке №8 выдерживается небольшая пауза, необходимая для того, чтобы после порождения
клиента, прежде, чем он начнет действовать, до него успело дойти сообщение от генератора
с количеством покупаемой пищи. Если эту строку убрать из плана, то при запуске модели,
время от времени, будет возникать ошибка невозможности реализовать намерения.
*/

@c2[atomic]
+!who_is_last[source(Customer)]:    
.all_names(A) & .substring(Customer, A) & inFront(_) & not behind(_) <-
	?numberInQueue(N);
	.my_name(MyName);
	.print("I last, ",Customer);
	.send(Customer,tell,queue(MyName,N)).
/*Если данный клиент получил от другого клиента запрос «кто крайний?», и при этом в его
базе убеждений присутствует убеждение, что он за кем-то занимал (inFront), и отсутствует
убеждение, что за ним кто-то занимал (behind), то он сообщает запросившему клиенту убеждение
«queue», в котором передает свое имя и собственный номер в очереди (строка 31). 
Обратите внимание, что в строке 27 путем комбинации функций
«.all_names(A) & .substring(Customer, A)» проверяется дополнительное условие существования
отправителя запроса «кто крайний?» в системе. Это необходимо потому, что неизвестно точно
* когда будет обработан полученный запрос. Возможны случаи, когда за прошедшее до момента
обработки время клиент-отправитель успеет решить свою задачу и будет завершен.
*/

@c3 +!who_is_last <- true.
/*Во всех остальных случаях, т.е. когда данный клиент не последний в очереди, при
получении запроса «кто крайний?» клиент не реагирует на данный запрос.
*/

@c4[atomic]
+queue(Agent,N): .count(queue(_,_),3) <-
	!selectQueue(LastInQueue);
	!setInQueue(LastInQueue);
	.abolish(queue(_,_)).
/* Если данный клиент получил в свою базу убеждений 3 предиката формата «queue(_,_)»,
т.е. собрал информацию о 3-х возможных очередях в соответствии с количеством продавцов,
то он должен выбрать подходящую очередь и занять в ней место (о чем ставятся
соответствующие подцели в строках 51 и 52). Передаваемая при вызове подцелей переменная
«LastInQueue» изначально является свободной переменной. Она необходима для передачи
информации между двумя подпланами. После занятия места в очереди первичную информацию
о размерах очередей можно забыть (строка 53).
*/

@c5[atomic]
	+!selectQueue(LastInQueue) <-
		.findall(N,queue(_,N),List);
		.min(List,MinQueueSize);
		?queue(LastInQueue,MinQueueSize).
/*В плане осуществляется выбор наиболее короткой очереди. В строке 65 вызывается функция
поиска всех возможных вариантов означиваний переменной N в убеждениях со структурой
* «queue(_,N)». Найденные варианты помещаются в список в переменную List. Далее в этом
списке находится минимальный элемент (строка 66) и помещается в переменную «MinQueueSize»,
после чего по значению этого элемента определяется имя агента, сообщившего минимальную
длину очереди и помещается в  «LastInQueue» (строка 67).
Обратите внимание, что переменная «LastInQueue» передается в план как свободная и только
в строке 67 принимает значение, которое и возвращается в родительский план. После чего из
родительского плана это значение передается в следующий подплан.
*/

@c6[atomic]
+!setInQueue(LastInQueue):sellers(S)&  .member(LastInQueue, S)  <-
	+inFront(LastInQueue);
	.print("I make a queue to ",LastInQueue,".");
	-+numberInQueue(1).
/*
В плане осуществляется постановка данного клиента в очередь в случае, если клиент в этой
очереди оказался первым. При этом имя продавца уже определено на этапе выбора очереди и
хранится в переменной «LastInQueue». Клиент запоминает, что перед ним стоит выбранный ранее
продавец (строка 81) и запоминает, что он первый в созданной очереди к этому
продавцу (строка 83).
 */
@c7[atomic]
+!setInQueue(LastInQueue):.all_names(A)& .substring(LastInQueue,A)&sellers(S)& not .member(LastInQueue, S) <-
	  .my_name(MyName);
	  ?queue(LastInQueue,N);
	  .print("I select a queue behind ",LastInQueue,". The queue size is ",N); 
      .send(LastInQueue,tell,behind(MyName));
      +inFront(LastInQueue);
      -+numberInQueue(N+1).
/*
В плане происходит постановка клиента в очередь, если данный клиент вынужден занимать ее за
другим клиентом. При этом дополнительно проверяется существование этого другого клиента, т.к.
возможен случай, что тот ответил и завершил работу. Имя другого клиента уже определено на этапе
выбора очереди и хранится в переменной «LastInQueue». Данный клиент сообщает другому клиенту,
что он за ним занимает (строка 96), сам запоминает за кем он стоит (строка 97), а также
запоминает свой номер в очереди (строка 98).
 */

@c8[atomic]
+!setInQueue<-
	!toPutOnQueueOnceMore.
/*Данный план срабатывает в случаях, когда не срабатывают предыдущие два плана.
Очевидно, что попытка занять очередь не удалась по причине завершения работы крайнего
в этой очереди. Следовательно нужно попытаться занять очередь еще раз.
*/

@c9[atomic]
+!toPutOnQueueOnceMore<- 
.drop_all_desires;
.print("OK, I ask once again: WHO IS LAST ???");
.broadcast(achieve, who_is_last).
/*План реализует еще одну попытку занять очередь, однако теперь надо предварительно
почистить память от намерений и убеждений, оставшихся с
предыдущей попытки (строка 118).
*/

@c10[atomic]
+inFront(Agent): sellers(S)& .member(Agent, S) <-
	?orderValue(X);
	.send(Agent,achieve,serveMe(X));
	.print("Now I must be served by ",Agent, "! My order is ",X).
/*План обрабатывает событие возникновения убеждения, что перед данным клиентом кто-то
стоит. Проверяется, является ли этот кто-то продавцом. Если да, то план срабатывает,
клиент просит продавца выдать ему порцию еды размером «X» (строка 129).
*/

@c11[atomic]
+behind(X): .count(behind(_), 2) <-
	.print("No, ",X," behind me occupied");
	.send(X,achieve,toPutOnQueueOnceMore);
	.abolish(behind(X)).
/*План предназначен для обработки конфликтной ситуации, когда у данного агента формируются 
убеждения, что за ним пытаются занять очередь двое. Тогда агент просит второго занимавшего
попытаться занять очередь еще раз и забывает о его существовании (строки 139, 140).
 */

@c12 +behind(X)<-
	.print("OK, ",X," you are behind me...").
/*Если не срабатывает предыдущий план, то данный агент может позволить агенту X занять за
ним очередь. Иначе говоря, убеждение «behind(X)» можно оставить в базе убеждений данного
агента. Обратите внимание, что этот план нельзя менять местами с предыдущим, т.к. благодаря
особенностям работы процедуры выбора конфликтующих планов, произойдет нарушение в логике
работы модели и очереди превратятся в деревья.
*/

@c13[atomic]
+!next:behind(X) <-	
	?numberInQueue(N);
	-+numberInQueue(N-1);
	.send(X,achieve,next).
/*
План моделирует продвижение данного клиента в очереди, при условии, что за ним еще кто-то
стоит. Клиент уменьшает значение своего счетчика очереди и посылает сзади стоящему клиенту
уведомление о продвижении.
 */
 
@c14[atomic]
+!next:not behind(_) <-
	?numberInQueue(N);
	-+numberInQueue(N-1).
/*План моделирует продвижение данного клиента в очереди, при условии, что за ним никто
не стоит. Клиент просто уменьшает значение своего счетчика очереди.
*/

@c15[atomic]
+meal(X)[source(Seller)]: behind(Y) <-
	.print("I got meal from ", Seller,". Who is next !? (",Y,")");
	.send(Y,achieve,seller(Seller));
	.send(Y,achieve,next);
	.send(generator,achieve,finishMe).
/*План моделирует получение клиентом заказа от продавца при условии, что за ним кто-то
стоит. Обслуженный клиент уходит (просит генератора клиентов завершить его работу,
строка 179), при этом сообщает имя продавца, обслуживающего данную очередь, следующему
клиенту (строка 177), и инициирует продвижение очереди (строка 176).
*/

@c16[atomic]
+meal(X)[source(Seller)]: not behind(Y) <-
	.print("  I got meal from ", Seller,". Our queue is empty !!!");
	.send(generator,achieve,finishMe).
/* План аналогичен предыдущему, только при условии, что за клиентом никто не стоит.
Обслуженный клиент просто уходит.
*/

@c17[atomic]
+!seller(Seller) <-
	-+inFront(Seller).
/*План подменяет убеждение о впередистоящем клиенте на убеждение о впередистоящем продавце.
Срабатывает, если данный клиент является вторым в очереди, когда обслуженный перед ним
клиент уходит и сообщает ему имя продавца.
*/