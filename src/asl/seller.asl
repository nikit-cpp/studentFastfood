// 1. База начальных убеждений
queue(0). //Флаг отсутствия очереди к данному продавцу
salesProceeds(0). // Выручка продавца.
maxServeDelay(2000). //Время обслуживания одного клиента

// 2. Планы по достижению целей (табл. 7)
@s1
+!who_is_last[source(Customer)]: queue(0) <-
	.my_name(MyName);
	.print("I HAVE NO QUEUE, ",Customer);
	.send(Customer, tell, queue(MyName,0)).
/*Если к продавцу нет очереди, то при получении запроса клиента «кто крайний», продавец
называет себя и говорит, что свободен (строка 11). */

@s2
+!who_is_last<-true.
/*Если к продавцу есть очередь, то при получении запроса клиента «кто крайний» он молчит.
*/

@s3
+!serveMe(X)[source(Customer)]: not capturedBy(_) <-
	+capturedBy(Customer);
	.print("  I'm captured by ", Customer);
	.abolish(queue(0));
	?maxServeDelay(Delay);
	.wait(Delay);
	.send(store, achieve, moreMeal(X)).

/*Если продавец не занят, то при получении от клиента запроса на обслуживание,
он его обрабатывает. При этом продавец устанавливает флаг занятости клиентом (строка 22),
сбрасывает флаг отсутствия очереди, выполняет задержку, имитирующую время облуживания
(строки 25, 26), и посылает запрос в хранилище (строка 27).
*/

@s4
+!serveMe(X)[source(Customer)]: capturedBy(_) <- 
	.print("I am busy, ",Customer," go to queue...");  
	.send(Customer, achieve, toPutOnQueueOnceMore).
/*Если продавец занят, и получает еще один запрос на обслуживание, то это означает
возникновение конфликта. Поэтому продавец сообщает отправителю запроса, что необходимо
занять очередь.
*/

@s5
+!takeMeal(X) <-
	?capturedBy(Customer);
	?salesProceeds(Y);     
	K=Y+X*10;          
	-+salesProceeds(K);
	.send(Customer, tell, meal(X));  
	.abolish(capturedBy(_)).
/*План моделирует акт продажи порции, объемом X (строка 50), и получения за нее выручки,
размером 10*X. В процессе работы модели выручка накапливается (строки 47, 48, 49). После
обслуживания данного клиента продавец освобождается для следующего (строка 51).
*/
